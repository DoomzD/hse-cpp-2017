# Семинар 4 (20 сентября 2017)

Практически ничего нового не было, в основном обсуждали ваши проблемы в домашних заданиях.

* Делать переменную цикла *size_t* -- не панацея. В таком примере слепое следование этому правилу превращается в фарс:

```cpp
int n;
cin >> n;
for (size_t i = 0; i < n; ++i) ...
```

* Не надо явно сравнивать булевые переменные с *true*/*false*.
* Разделяйте блоки кода пустыми строками. Если cpplint ругается на ваш код, скорее всего строка на самом деле не пустая, а состоит из пробелов. Настройте ваш редактор так, чтобы он не ставил пробелы в конце строк.
* Для того, чтобы получить максимальное или минимальное значение типа, можно использовать `std::numeric_limits<int>::max()`.
* Операторы, которые модифируют объект (например, `+=`), должны возвращать ссылку на текущий объект. Это делается с помощью ключевого слова `this`, которое указывает на текущий объект.

```cpp
A& operator+=(int x) {
    value += x;
    return *this;
}
```

Тогда будет возможна следующая запись (я не говорю, что так следует когда-то делать, но таковы конвенции):

```cpp
A a;
A b = (a += 10 += 20 += 30);
```

* Если вам нужно написать *if*, условие в котором занимает несколько строк, его нужно аккуратно отформатировать. Главное, чтобы было видно, где заканчивается условие и начинается тело, и чтобы можно было понять, где какой уровень вложенности скобок в условии. Можно делать, например. так:

```cpp
if (year % 4 == 0 &&
        (year % 100 != 0 && year % 400 == 0)) {
    cout << "is leap" << endl;
}

if (year % 4 == 0 &&
        (year % 100 != 0 && year % 400 == 0)
) {
    cout << "is leap" << endl;
}

if (someLongBoolStatement &&
        someOtherStatement &&
        (somethingInsideParens ||
            somethingElseInsideParens) &&
        stuffOutsideAgain) {
    cout << "wow" << endl;
}
```

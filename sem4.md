# Семинар 4 (15 сентября 2017)

### Структуры

*struct* и *class* с точки зрения языка отличаются только тем, что в первом область видимости по умолчанию – public, а во втором – private (ещё структуры по умолчанию наследуются публично, а классы – приватно). Но мы для упрощения терминологии будем называть нашу сущность структурой, пока мы не определили в ней методы и конструкторы, и классом в противном случае.

Базовый синтаксис объявления структуры (обратите внимание на точку с запятой в конце):

```cpp
struct Point {
    int x, y;
};
```

#### Конструкторы

По умолчанию все поля структуры инициализируются так же, как если бы вы создали их как переменные: int будет мусором, вектор – пустым, и т.д. Для того, чтобы заполнить поля так, как вам нужно, используются так называемые конструкторы.

```cpp
struct Point {
    int x, y;
    Point(int x_, int y_) {
        x = x_;
        y = y_;
    }
};

int main() {
    Point p1(10, 20);
}
```

Если написать конструктор так, то поля класса сначала создадутся, а потом перезапишутся в конструкторе. Если поля – это какие-то сложные большие типы, и копирования хочется избегать, есть другой способ написания конструктора. Он отличается тем, что вы сразу создаёте поля с теми аргументами, с которыми хотите.

```cpp
struct Point {
    int x, y;
    Point(int x_, int y_) :
        x(x_),
        y(y_)
    {  }
};
```

Не забудьте определить у своей структуры пустой конструктор, иначе у вас не получится, например, создать массив структур. Пустой конструктор может выглядеть просто как `Point() {}`.

#### Функции ввода-вывода

Напишем функции для считывания и вывода нашей структуры.

```cpp
istream& operator>>(istream& in, Point& p) {
    return in >> p.x >> p.y;
}

osteram& operator<<(ostream& out, const Point& p) {
    return out << p.x << " " << p.y;
}
```

Зачем столько ссылок? Чтобы можно было пользоваться *cin* так, как вы привыкли. Давайте поставим скобки в типичной конструкции, чтобы разобраться, как она работает.

```cpp
cin >> x >> y >> z;
((cin >> x) >> y) >> z;
```

Каждая операция внутри скобок – это оператор *>>* между ссылкой на *cin* и ссылкой на считываемый объект. Первая ссылка нужна, чтобы модифицировать входной поток (например, указатель на текущее положение потока), вторая – чтобы собственно изменить объект, который вы считываете. Вернуть ссылку на cin нужно, чтобы последующие операторы могли работать с ним точно так же.

#### Операторы сравнения

Если сейчас создать вектор *Point*-ов и попытаться его отсортировать, мы потерпим неудачу. Компилятор вывалит на вас несколько экранов текста, пытаясь тем самым сказать, что он не знает, как сравнивать ваши точки! Есть несколько способов его «научить».

* Передать в функцию компаратор:
```cpp
bool cmp(const Point& lhs, const Point& rhs) {
    if (lhs.x = rhs.x) {
        return lhs.y < rhs.y;
    }
    return lhs.x < rhs.x;
}

int main() {
    sort(a.begin(), a.end(), cmp);
}
```

* Определить свободную функцию-оператор (в таком случае в cортировку не нужно передавать дополнительных аргументов):
```cpp
bool operator<(const Point& lhs, const Point& rhs) {
    // comparison code here
}
```

* Определить метод-оператор внутри класса (для пользователей это практически не отличается от предыдущего способа):
```cpp
struct Point {
    int x, y;
    bool operator<(const Point& other) const {
        // comparison code here
    }
};
```
 Обратите внимание на второе слово *const*. Оно обозначает, что этот метод – константный, т.е. никак не модифицирует объект. Если у вас есть константный экземпяр какого-то класса, то вы можете вызывать у него только те методы, которые объявлены с модификатором const.

* Определить лябмда-функцию:
```cpp
sort(a.begin(), a.end(), [](const Point& lhs, const Point& rhs) {
    // comparison code here
});
```

### Лябмды

Лямбда-функцию можно представлять как функцию без имени. Выражение состоит из трёх частей: квадратных скобок, круглых скобок со списком аргументов (как в обычной функции) и тела в фигурных скобках (опять же, как в обычной функции).

Лябмду можно сохранить с помощью *auto* или специального типа *std::function<type(arguments)>*:

```cpp
auto add = [](int x, int y) { return x + y; };

std::function<double(int)> twiceSquareRoot = [](int x) {
    return 2.0 * sqrt(static_cast<double>(x));
};

cout << add(10, 20) << " " << twiceSquareRoot(5) << endl;
```

Лямбды подходящего типа можно передавать в те места, где от вас ожидают обычные функции, как в случае с сортировкой.

#### Тип возвращаемого значения лябмды
Компилятор сам пытается угадать, какой тип возвращает ваша анонимная функция. Если в ней ни одного оператора *return* с параметром, это будет *void*. Если все *return*-ы имеют один и тот же тип, он и будет возвращаемым значением. В более сложных случаях можно указать вовзращаемый тип явно. В таком случае вовзвращаемое значение будет автоматически скастовано к этому типу.

```cpp
auto returnInt = []() -> int {
    if (something) {
        return 1.0;
    } else if (something_else) {
        return 'a';
    } else {
        return 10;
    }
};
```

#### Захват переменных в лямбду

По умолчанию изнутри лябмда-функции не видно никаких внешних переменных (только глобальных). Чтобы переменная стала доступна, её надо «захватить» (capture). Это можно делать двумя способами: по ссылке и по значению.

Захват по ссылке выглядит так:

```cpp
vector<int> a;
auto adder = [&a](int x) { a.push_back(x); };
```

Захват по значению – так же, только без символа ссылки. Захватить можно любое количество переменных, при этом амперсанд надо ставить перед каждой переменной, которую вы захватываете по ссылке.

Можно захватить все имеющиеся переменные по ссылке: `[&]`. Или по значению: `[=]`.

Все переменные, которые захватываются по значению, копируются и становятся константными. Это сделано для того, чтобы результат вызова лябмды оставался каждый раз постоянным. Для того, чтобы захвать переменную по значению, но при этом иметь возможность её изменять, нужно использовать ключевое слово *mutable*:

```cpp
vector<int> a;
int counter = 0;
auto func = [a, counter] () mutable {
    a.push_back(counter++);
};

func();
func();
cout << a.size() << " " << counter << endl; // 0 0
```

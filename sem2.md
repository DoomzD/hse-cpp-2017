# Семинар 2 (8 сентября 2017)

### Вставка в вектор по итератору

```
a[0]      a[1]      a[2]    
begin     begin+1   begin+2   end

```

Конструкция `a.insert(iter, x)` вставляет элемент *x* *перед* итератором *iter*. Это сделано
для того, чтобы можно было вставить элемент в начало. В частности, операция
`a.insert(a.end(), x)` всегда валидна, хоть *end* указывает на невалидный элемент.

### emplace/emplace_back
Как вставить пару (*std::pair*) в вектор? Есть несколько способов.

```cpp
a.push_back(std::pair<int, int>(5, 8));
a.push_back(std::make_pair(5, 8));
a.push_back({5, 8});
a.emplace_back(5, 8);
```

Последний способ не только красивее выглядит, но и быстрее работает. Метод *push_back*
принимает на вход элемент, который затем копирует в конец вектора. *emplace_back* же
принимает *аргументы* для создания нового элемента, создавая его сразу в нужном
месте и тем самым избегая лишнего копирования.

Точно так же работает метод *emplace*, в остальном аналогичный *insert*:
`a.emplace(a.begin() + 100, 5, 8)`.

### Инвалидация итераторов
Итераторам не всегда можно доверять. К примеру, следующий код легко может вызвать падение
программы:

```cpp
vector<int> a;
a.push_back(1);
auto it = a.begin();
a.push_back(2);
cout << *it << endl;
```

Дело в том, что после изменения объекта итераторы на его элементы не всегда остаются валидными.
В случае вектора итератор можно воспринимать как обычный указатель. Когда происходит
реаллокация, старая область памяти целиком удаляется, и старые итераторы начинают указывать
«в никуда».

Плохая новость в том, что отследить валидность итераторов никак невозможно, поэтому вам нужно
следить за их сохранностью самостоятельно. Для этого нужно стараться не модифицировать
контейнеры между созданием итератора и его использованием, а если уж вам нужно это сделать,
то внимательно смотреть на [cppreference](http://cppreference.com), в каких случаях итераторы
инвалидируются, а в каких остаются корректными.

Хорошая же новость -- способ отследить валидность итераторов всё-таки есть. Для этого вам нужно
дописать в начало программы (перед всеми *include*) строчку `#define _GLIBCXX_DEBUG`.
После этого стандартная библиотека будет работать в дебажном режиме. Включится много проверок,
в том числе на доступ к вектору по некорректному индексу, бинпоиску на неотсортированном
массиве и операциям с инвалидированными итераторами.

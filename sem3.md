# Семинар 2 (13 сентября 2017)

### Типичные замечания к коду

* Не надо использовать *<bits/stdc++.h>*. Во-первых, стоит запоминать, в каких хедерах что лежит, во-вторых, он есть не подо все компиляторы.
* Проверять контейнер на пустоту нужно через `a.empty()`, а не с помощью `a.size() == 0`, потому что *size* в некоторых контейнерах может работать за линейное время (например, в случае списка).
* Если вы объявляете какую-то переменную или массив константными (какой-то захардкоженный список или модуль в задаче на модульную арифметику), добавьте модификатор *const*. Это защищает от ошибок и помогает оптимизатору.
* Не надо сравнивать знаковые и беззнаковые типы: писать `for (int i = 0; i < a.size(); ++i)` нельзя, либо делайте *static_cast*, либо объявляйте *i* как беззнаковый тип.
* В конце программы нужно обязательно выводить перевод строки.

### Несколько слов про ссылки и функцию swap

Помните, что ссылки могут указывать на один и тот же объект. Например, из-за этого такая реализация функции *swap* ошибочна (не надо так писать никогда, это академический пример!):

```cpp
void swap(int &x, int &y) {
    x += y;
    y = x - y;
    x = x - y;
}
```

Если попытаться вызвать `swap(x, x)`, произойдёт не то, что вы ожидаете.

#### swap стандартных контейнеров
У многих контейнеров стандартной библиотеки определён метод *swap*:

```cpp
vector<int> a, b;
a.swap(b);
```

Обычно он работает за *O(1)*, потому что в случае векторов, например, достаточно просто поменять местами указатели на массивы объектов, а сами объекты копировать не нужно.

Свободная функция *swap* это учитывает. Она устроена примерно так:

```cpp
template<typename T>
void swap(T& lhs, T& rhs) {
    if (method lhs.swap(rhs) exists) { // псевдокод
        lhs.swap(rhs);
    } else {
        auto t = lhs;
        lhs = rhs;
        rhs = t;
    }
}
```

Проверить, существует ли метод у объекта, достаточно сложно, но это можно сделать средствами языка. Кому интересно – гуглите аббревиатуру SFINAE.

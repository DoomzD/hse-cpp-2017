# Семинар 9 (4 октября 2017)

Говорили про алгоритмы с итераторами, писали свой класс для взятия по модулю c реализацией необходимых операторов. Ещё разбирали примеры работы с юникодом.

### Юникод

Символы, записанные в UTF-8 (кодировка для записи юникода), могут состоять из нескольких байт. Например, если считать в программе строку, состоящую из одной русской буквы "А", то длина строки окажется равной 2, потому что для записи этого символа требуется два байта.

Если попытаться вывести числовые значения этих символов на экран, могут появиться отрицательные числа. Это нормально: на некоторых платформах сhar -- знаковый тип, а в юникодных байтах старший бит часто установлен в 1, поэтому получается отрицательное значение. Чтобы увидеть значение по модулю, нужно скастовать символ сначала в uint8_t (это сделает его беззнаковым), а затем в unsigned int (это выведет на экран числовое значение, а не сам символ).

Вывод работает аналогично: чтобы вывести на экран русскую букву, вам нужно напечатать два байта подряд с соответствующими значениями. Терминал сам интерпретирует это как юникод и покажет одну букву, несмотря на то, что было выведено два байта.

### Пара идиом про итераторы
Часто в алгоритмах нужно одновременно инкрементировать итераторы и присваивать им что-то. Не нужно бояться делать это в одном выражении, но не стоит забывать о приоритете операторов.

| Выражение         | Эквивалент со скобками    | Описание                                                                  |
|-------------------|---------------------------|---------------------------------------------------------------------------|
| *cur++            | *(cur++) или *cur; ++cur; | Взять значение, затем инкрементировать итератор                           |
| *++cur            | *(++cur) или ++cur; *cur; | Инкрементировать итератор, затем взять значение                           |
| (*cur)++          | (*cur)++                  | Инкрементировать значение, на котрое указывает сur                        |
| *cur++ = *first++ | *(cur++) = *(first++)     | Присвоить в *cur значение из *first, затем инкрементировать оба итератора |

### Пример класса с перегруженными операторами
```cpp
template<int N>
class Zn {
public:
    Zn() : x_(0) {  }

    Zn(int x) : x_(x) {
        static_assert(N > 0 && N <= (1 << 30), "Bad N");
        normalize();
    }

    int x() const {
        return x_;
    }

    Zn<N>& operator+=(const Zn<N>& other) {
        x_ += other.x_;
        normalize();
        return *this;
    }

    Zn<N> operator+(const Zn<N>& other) const {
        Zn<N> t(*this);
        return t += other;
    }

    Zn<N>& operator-=(const Zn<N>& other) {
        x_ -= other.x_;
        normalize();
        return *this;
    }

    Zn<N> operator-(const Zn<N>& other) const {
        Zn<N> t(*this);
        return t -= other;
    }

    Zn<N>& operator++() {
        ++x_;
        normalize();
        return *this;
    }

    Zn<N> operator++(int) {
        Zn<N> t(*this);
        ++*this;
        return t;
    }


private:
    void normalize() {
        x_ = (x_ % N + N) % N;
    }

    int x_;
};
```

Из этого примера можно извлечь несколько полезных вещей.

* Если ваш объект должен поддерживать какой-то инвариант, стоит написать функцию, которая за ним следит
    (*normalize*) и вызывать её когда нужно, а не следить за логикой руками;
* Операторы + и - можно реализовывать через += и -=, так не нужно прописывать операции дважды и вы
    не создадите лишних временных объектов;
* Для того, чтобы переопределить постфиксный operator++, нужно передать ему в конструкторы неименованый
    параметр типа int. Обращаться к параметру нельзя, передавать тоже не стоит, это просто конвенция
    компилятора.
